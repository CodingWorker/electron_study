<h1>BrowserWindow</h1>
<p><code>BrowserWindow</code> 类让你有创建一个浏览器窗口的权力。例如:</p>
<p>```javascript
// In the main process.
const BrowserWindow = require('electron').BrowserWindow;</p>
<p>// Or in the renderer process.
const BrowserWindow = require('electron').remote.BrowserWindow;</p>
<p>var win = new BrowserWindow({ width: 800, height: 600, show: false });
win.on('closed', function() {
  win = null;
});</p>
<p>win.loadURL('https://github.com');
win.show();
```</p>
<p>你也可以不通过chrome创建窗口，使用
<a href="frameless-window.html">Frameless Window</a> API.</p>
<h2>Class: BrowserWindow</h2>
<p><code>BrowserWindow</code> 是一个
<a href="http://nodejs.org/api/events.html#events_class_events_eventemitter">EventEmitter</a>.</p>
<p>通过 <code>options</code> 可以创建一个具有本质属性的 <code>BrowserWindow</code> .</p>
<h3><code>new BrowserWindow([options])</code></h3>
<ul>
<li>
<code>options</code> Object
<ul>
<li><code>width</code> Integer - 窗口宽度,单位像素. 默认是 <code>800</code>.</li>
<li><code>height</code> Integer - 窗口高度,单位像素. 默认是 <code>600</code>.</li>
<li><code>x</code> Integer - 窗口相对于屏幕的左偏移位置.默认居中.</li>
<li><code>y</code> Integer - 窗口相对于屏幕的顶部偏移位置.默认居中.</li>
<li><code>useContentSize</code> Boolean - <code>width</code> 和 <code>height</code> 使用web网页size, 这意味着实际窗口的size应该包括窗口框架的size，稍微会大一点，默认为 <code>false</code>.</li>
<li><code>center</code> Boolean - 窗口屏幕居中.</li>
<li><code>minWidth</code> Integer - 窗口最小宽度，默认为 <code>0</code>.</li>
<li><code>minHeight</code> Integer - 窗口最小高度，默认为 <code>0</code>.</li>
<li><code>maxWidth</code> Integer - 窗口最大宽度，默认无限制.</li>
<li><code>maxHeight</code> Integer - 窗口最大高度，默认无限制.</li>
<li><code>resizable</code> Boolean - 是否可以改变窗口size，默认为 <code>true</code>.</li>
<li><code>movable</code> Boolean - 窗口是否可以拖动. 在 Linux 上无效. 默认为 <code>true</code>.</li>
<li><code>minimizable</code> Boolean - 窗口是否可以最小化. 在 Linux 上无效. 默认为 <code>true</code>.</li>
<li><code>maximizable</code> Boolean - 窗口是否可以最大化. 在 Linux 上无效. 默认为 <code>true</code>.</li>
<li><code>closable</code> Boolean - 窗口是否可以关闭. 在 Linux 上无效. 默认为 <code>true</code>.</li>
<li><code>alwaysOnTop</code> Boolean - 窗口是否总是显示在其他窗口之前. 在 Linux 上无效. 默认为 <code>false</code>.</li>
<li><code>fullscreen</code> Boolean - 窗口是否可以全屏幕. 当明确设置值为When <code>false</code> ，全屏化按钮将会隐藏，在 OS X 将禁用. 默认 <code>false</code>.</li>
<li><code>fullscreenable</code> Boolean - 在 OS X 上，全屏化按钮是否可用，默认为 <code>true</code>.</li>
<li><code>skipTaskbar</code> Boolean - 是否在人物栏中显示窗口. 默认是<code>false</code>.</li>
<li><code>kiosk</code> Boolean - kiosk 方式. 默认为 <code>false</code>.</li>
<li><code>title</code> String - 窗口默认title. 默认 <code>&quot;Electron&quot;</code>.</li>
<li><code>icon</code> <a href="native-image.html">NativeImage</a> - 窗口图标, 如果不设置，窗口将使用可用的默认图标.</li>
<li><code>show</code> Boolean - 窗口创建的时候是否显示. 默认为 <code>true</code>.</li>
<li><code>frame</code> Boolean - 指定 <code>false</code> 来创建一个
<a href="frameless-window.html">Frameless Window</a>. 默认为 <code>true</code>.</li>
<li><code>acceptFirstMouse</code> Boolean - 是否允许单击web view来激活窗口 . 默认为 <code>false</code>.</li>
<li><code>disableAutoHideCursor</code> Boolean - 当 typing 时是否隐藏鼠标.默认 <code>false</code>.</li>
<li><code>autoHideMenuBar</code> Boolean - 除非点击 <code>Alt</code>，否则隐藏菜单栏.默认为 <code>false</code>.</li>
<li><code>enableLargerThanScreen</code> Boolean - 是否允许允许改变窗口大小大于屏幕. 默认是 <code>false</code>.</li>
<li><code>backgroundColor</code> String -窗口的 background color 值为十六进制,如 <code>#66CD00</code> 或 <code>#FFF</code> 或 <code>#80FFFFFF</code> (支持透明度). 默认为在 Linux 和 Windows 上为
<code>#000</code> (黑色) , Mac上为 <code>#FFF</code>(或透明).</li>
<li><code>hasShadow</code> Boolean - 窗口是否有阴影. 只在 OS X 上有效. 默认为 <code>true</code>.</li>
<li><code>darkTheme</code> Boolean - 为窗口使用 dark 主题, 只在一些拥有 GTK+3 桌面环境上有效. 默认为 <code>false</code>.</li>
<li><code>transparent</code> Boolean - 窗口 <a href="frameless-window.html">透明</a>.
默认为 <code>false</code>.</li>
<li><code>type</code> String - 窗口type, 默认普通窗口. 下面查看更多.</li>
<li><code>titleBarStyle</code> String - 窗口标题栏样式. 下面查看更多.</li>
<li><code>webPreferences</code> Object - 设置界面特性. 下面查看更多.</li>
</ul>
</li>
</ul>
<p><code>type</code> 的值和效果不同平台展示效果不同，具体:</p>
<ul>
<li>Linux, 可用值为 <code>desktop</code>, <code>dock</code>, <code>toolbar</code>, <code>splash</code>,
  <code>notification</code>.</li>
<li>
OS X, 可用值为 <code>desktop</code>, <code>textured</code>.
<ul>
<li><code>textured</code> type 添加金属梯度效果
(<code>NSTexturedBackgroundWindowMask</code>).</li>
<li><code>desktop</code> 设置窗口在桌面背景窗口水平
(<code>kCGDesktopWindowLevel - 1</code>). 注意桌面窗口不可聚焦, 不可不支持键盘和鼠标事件, 但是可以使用 <code>globalShortcut</code> 来解决输入问题.</li>
</ul>
</li>
</ul>
<p><code>titleBarStyle</code> 只在 OS X 10.10 Yosemite 或更新版本上支持.
可用值:</p>
<ul>
<li><code>default</code> 以及无值, 显示在 Mac 标题栏上为不透明的标准灰色.</li>
<li><code>hidden</code> 隐藏标题栏，内容充满整个窗口, 然后它依然在左上角，仍然受标准窗口控制.</li>
<li><code>hidden-inset</code>主体隐藏，显示小的控制按钮在窗口边缘.</li>
</ul>
<p><code>webPreferences</code> 参数是个对象，它的属性:</p>
<ul>
<li><code>nodeIntegration</code> Boolean - 是否完整支持node. 默认为 <code>true</code>.</li>
<li><code>preload</code> String - 界面的其它脚本运行之前预先加载一个指定脚本. 这个脚本将一直可以使用 node APIs 无论 node integration 是否开启. 脚本路径为绝对路径.
  当 node integration 关闭, 预加载的脚本将从全局范围重新引入node的全局引用标志. 查看例子
  <a href="process.md#event-loaded">here</a>.</li>
<li><code>session</code> <a href="session.md#class-session">Session</a> - 设置界面session. 而不是直接忽略session对象 , 也可用 <code>partition</code> 来代替, 它接受一个 partition 字符串. 当同时使用 <code>session</code> 和 <code>partition</code>, <code>session</code> 优先级更高.
  默认使用默认 session.</li>
<li><code>partition</code> String - 通过session的partition字符串来设置界面session. 如果 <code>partition</code> 以 <code>persist:</code> 开头, 这个界面将会为所有界面使用相同的 <code>partition</code>. 如果没有 <code>persist:</code> 前缀, 界面使用历史session. 通过分享同一个 <code>partition</code>, 所有界面使用相同的session. 默认使用默认 session.</li>
<li><code>zoomFactor</code> Number - 界面默认缩放值, <code>3.0</code> 表示
  <code>300%</code>. 默认 <code>1.0</code>.</li>
<li><code>javascript</code> Boolean - 开启javascript支持. 默认为<code>true</code>.</li>
<li><code>webSecurity</code> Boolean - 当设置为 <code>false</code>, 它将禁用相同地方的规则 (通常测试服), 并且如果有2个非用户设置的参数，就设置
  <code>allowDisplayingInsecureContent</code> 和 <code>allowRunningInsecureContent</code> 的值为
  <code>true</code>. 默认为 <code>true</code>.</li>
<li><code>allowDisplayingInsecureContent</code> Boolean -允许一个使用 https的界面来展示由 http URLs 传过来的资源. 默认<code>false</code>.</li>
<li><code>allowRunningInsecureContent</code> Boolean - Boolean -允许一个使用 https的界面来渲染由 http URLs 提交的html,css,javascript. 默认为 <code>false</code>.</li>
<li><code>images</code> Boolean - 开启图片使用支持. 默认 <code>true</code>.</li>
<li><code>textAreasAreResizable</code> Boolean - textArea 可以编辑. 默认为 <code>true</code>.</li>
<li><code>webgl</code> Boolean - 开启 WebGL 支持. 默认为 <code>true</code>.</li>
<li><code>webaudio</code> Boolean - 开启 WebAudio 支持. 默认为 <code>true</code>.</li>
<li><code>plugins</code> Boolean - 是否开启插件支持. 默认为 <code>false</code>.</li>
<li><code>experimentalFeatures</code> Boolean - 开启 Chromium 的 可测试 特性.
  默认为 <code>false</code>.</li>
<li><code>experimentalCanvasFeatures</code> Boolean - 开启 Chromium 的 canvas 可测试特性. 默认为 <code>false</code>.</li>
<li><code>directWrite</code> Boolean - 开启窗口的 DirectWrite font 渲染系统. 默认为 <code>true</code>.</li>
<li><code>blinkFeatures</code> String - 以 <code>,</code> 分隔的特性列表, 如
  <code>CSSVariables,KeyboardEventKey</code>. 被支持的所有特性可在 <a href="https://code.google.com/p/chromium/codesearch#chromium/src/out/Debug/gen/blink/platform/RuntimeEnabledFeatures.cpp&amp;sq=package:chromium&amp;type=cs&amp;l=527">setFeatureEnabledFromString</a>
  中找到.</li>
<li>
<code>defaultFontFamily</code> Object - 设置 font-family 默认字体.
<ul>
<li><code>standard</code> String - 默认为 <code>Times New Roman</code>.</li>
<li><code>serif</code> String - 默认为 <code>Times New Roman</code>.</li>
<li><code>sansSerif</code> String - 默认为 <code>Arial</code>.</li>
<li><code>monospace</code> String - 默认为 <code>Courier New</code>.</li>
</ul>
</li>
<li><code>defaultFontSize</code> Integer - 默认为 <code>16</code>.</li>
<li><code>defaultMonospaceFontSize</code> Integer - 默认为 <code>13</code>.</li>
<li><code>minimumFontSize</code> Integer - 默认为 <code>0</code>.</li>
<li><code>defaultEncoding</code> String - 默认为 <code>ISO-8859-1</code>.</li>
</ul>
<h2>事件</h2>
<p><code>BrowserWindow</code> 对象可触发下列事件:</p>
<p><strong>注意:</strong> 一些事件只能在特定os环境中触发，已经尽可能地标出.</p>
<h3>Event: 'page-title-updated'</h3>
<p>返回:</p>
<ul>
<li><code>event</code> Event</li>
</ul>
<p>当文档改变标题时触发,使用 <code>event.preventDefault()</code> 可以阻止原窗口的标题改变.</p>
<h3>Event: 'close'</h3>
<p>返回:</p>
<ul>
<li><code>event</code> Event</li>
</ul>
<p>在窗口要关闭的时候触发. 它在DOM的 <code>beforeunload</code> and <code>unload</code> 事件之前触发.使用 <code>event.preventDefault()</code> 可以取消这个操作</p>
<p>通常你想通过 <code>beforeunload</code> 处理器来决定是否关闭窗口，但是它也会在窗口重载的时候被触发. 在 Electron 中，返回一个空的字符串或 <code>false</code> 可以取消关闭.例如:</p>
<p>```javascript
window.onbeforeunload = function(e) {
  console.log('I do not want to be closed');</p>
<p>// Unlike usual browsers, in which a string should be returned and the user is
  // prompted to confirm the page unload, Electron gives developers more options.
  // Returning empty string or false would prevent the unloading now.
  // You can also use the dialog API to let the user confirm closing the application.
  e.returnValue = false;
};
```</p>
<h3>Event: 'closed'</h3>
<p>当窗口已经关闭的时候触发.当你接收到这个事件的时候，你应当删除对已经关闭的窗口的引用对象和避免再次使用它.</p>
<h3>Event: 'unresponsive'</h3>
<p>在界面卡死的时候触发事件.</p>
<h3>Event: 'responsive'</h3>
<p>在界面恢复卡死的时候触发.</p>
<h3>Event: 'blur'</h3>
<p>在窗口失去焦点的时候触发.</p>
<h3>Event: 'focus'</h3>
<p>在窗口获得焦点的时候触发.</p>
<h3>Event: 'maximize'</h3>
<p>在窗口最大化的时候触发.</p>
<h3>Event: 'unmaximize'</h3>
<p>在窗口退出最大化的时候触发.</p>
<h3>Event: 'minimize'</h3>
<p>在窗口最小化的时候触发.</p>
<h3>Event: 'restore'</h3>
<p>在窗口从最小化恢复的时候触发.</p>
<h3>Event: 'resize'</h3>
<p>在窗口size改变的时候触发.</p>
<h3>Event: 'move'</h3>
<p>在窗口移动的时候触发.</p>
<p>注意：在 OS X 中别名为 <code>moved</code>.</p>
<h3>Event: 'moved' <em>OS X</em></h3>
<p>在窗口移动的时候触发.</p>
<h3>Event: 'enter-full-screen'</h3>
<p>在的窗口进入全屏状态时候触发.</p>
<h3>Event: 'leave-full-screen'</h3>
<p>在的窗口退出全屏状态时候触发.</p>
<h3>Event: 'enter-html-full-screen'</h3>
<p>在的窗口通过 html api 进入全屏状态时候触发.</p>
<h3>Event: 'leave-html-full-screen'</h3>
<p>在的窗口通过 html api 退出全屏状态时候触发.</p>
<h3>Event: 'app-command' <em>Windows</em></h3>
<p>在请求一个<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms646275(v=vs.85).aspx">App Command</a>的时候触发.
典型的是键盘媒体或浏览器命令, Windows上的 &quot;Back&quot; 按钮用作鼠标也会触发.</p>
<p><code>js
someWindow.on('app-command', function(e, cmd) {
  // Navigate the window back when the user hits their mouse back button
  if (cmd === 'browser-backward' &amp;&amp; someWindow.webContents.canGoBack()) {
    someWindow.webContents.goBack();
  }
});</code></p>
<h3>Event: 'scroll-touch-begin' <em>OS X</em></h3>
<p>在滚动条事件开始的时候触发.</p>
<h3>Event: 'scroll-touch-end' <em>OS X</em></h3>
<p>在滚动条事件结束的时候触发.</p>
<h2>方法</h2>
<p><code>BrowserWindow</code> 对象有如下方法:</p>
<h3><code>BrowserWindow.getAllWindows()</code></h3>
<p>返回一个所有已经打开了窗口的对象数组.</p>
<h3><code>BrowserWindow.getFocusedWindow()</code></h3>
<p>返回应用当前获得焦点窗口,如果没有就返回 <code>null</code>.</p>
<h3><code>BrowserWindow.fromWebContents(webContents)</code></h3>
<ul>
<li><code>webContents</code> <a href="web-contents.html">WebContents</a></li>
</ul>
<p>根据 <code>webContents</code> 查找窗口.</p>
<h3><code>BrowserWindow.fromId(id)</code></h3>
<ul>
<li><code>id</code> Integer</li>
</ul>
<p>根据 id 查找窗口.</p>
<h3><code>BrowserWindow.addDevToolsExtension(path)</code></h3>
<ul>
<li><code>path</code> String</li>
</ul>
<p>添加位于 <code>path</code> 的开发者工具栏扩展,并且返回扩展项的名字.</p>
<p>这个扩展会被添加到历史，所以只需要使用这个API一次，这个api不可用作编程使用.</p>
<h3><code>BrowserWindow.removeDevToolsExtension(name)</code></h3>
<ul>
<li><code>name</code> String</li>
</ul>
<p>删除开发者工具栏名为 <code>name</code> 的扩展.</p>
<h2>实例属性</h2>
<p>使用 <code>new BrowserWindow</code> 创建的实例对象，有如下属性:</p>
<p><code>javascript
// In this example `win` is our instance
var win = new BrowserWindow({ width: 800, height: 600 });</code></p>
<h3><code>win.webContents</code></h3>
<p>这个窗口的 <code>WebContents</code> 对象，所有与界面相关的事件和方法都通过它完成的.</p>
<p>查看 <a href="web-contents.html"><code>webContents</code> documentation</a> 的方法和事件.</p>
<h3><code>win.id</code></h3>
<p>窗口的唯一id.</p>
<h2>实例方法</h2>
<p>使用 <code>new BrowserWindow</code> 创建的实例对象，有如下方法:</p>
<p><strong>注意:</strong> 一些方法只能在特定os环境中调用，已经尽可能地标出.</p>
<h3><code>win.destroy()</code></h3>
<p>强制关闭窗口, <code>unload</code> and <code>beforeunload</code> 不会触发，并且 <code>close</code> 也不会触发, 但是它保证了 <code>closed</code> 触发.</p>
<h3><code>win.close()</code></h3>
<p>尝试关闭窗口，这与用户点击关闭按钮的效果一样. 虽然网页可能会取消关闭，查看 <a href="#event-close">close event</a>.</p>
<h3><code>win.focus()</code></h3>
<p>窗口获得焦点.</p>
<h3><code>win.isFocused()</code></h3>
<p>返回 boolean, 窗口是否获得焦点.</p>
<h3><code>win.show()</code></h3>
<p>展示并且使窗口获得焦点.</p>
<h3><code>win.showInactive()</code></h3>
<p>展示窗口但是不获得焦点.</p>
<h3><code>win.hide()</code></h3>
<p>隐藏窗口.</p>
<h3><code>win.isVisible()</code></h3>
<p>返回 boolean, 窗口是否可见.</p>
<h3><code>win.maximize()</code></h3>
<p>窗口最大化.</p>
<h3><code>win.unmaximize()</code></h3>
<p>取消窗口最大化.</p>
<h3><code>win.isMaximized()</code></h3>
<p>返回 boolean, 窗口是否最大化.</p>
<h3><code>win.minimize()</code></h3>
<p>窗口最小化. 在一些os中，它将在dock中显示.</p>
<h3><code>win.restore()</code></h3>
<p>将最小化的窗口恢复为之前的状态.</p>
<h3><code>win.isMinimized()</code></h3>
<p>返回 boolean, 窗口是否最小化.</p>
<h3><code>win.setFullScreen(flag)</code></h3>
<ul>
<li><code>flag</code> Boolean</li>
</ul>
<p>设置是否全屏.</p>
<h3><code>win.isFullScreen()</code></h3>
<p>返回 boolean, 窗口是否全屏化.</p>
<h3><code>win.setAspectRatio(aspectRatio[, extraSize])</code> <em>OS X</em></h3>
<ul>
<li><code>aspectRatio</code> 维持部分视图内容窗口的高宽比值.</li>
<li>
<code>extraSize</code> Object (可选) - 维持高宽比值时不包含的额外size.
<ul>
<li><code>width</code> Integer</li>
<li><code>height</code> Integer</li>
</ul>
</li>
</ul>
<p>由一个窗口来维持高宽比值. <code>extraSize</code> 允许开发者使用它，它的单位为像素，不包含在 <code>aspectRatio</code> 中.这个 API 可用来区分窗口的size和内容的size .</p>
<p>想象一个普通可控的HD video 播放器窗口. 假如左边缘有15控制像素，右边缘有25控制像素，在播放器下面有50控制像素.为了在播放器内保持一个 16:9 的高宽比例，我们可以调用这个api传入参数16/9 and
[ 40, 50 ].第二个参数不管网页中的额外的宽度和高度在什么位置，只要它们存在就行.只需要把网页中的所有额外的高度和宽度加起来就行.</p>
<h3><code>win.setBounds(options[, animate])</code></h3>
<ul>
<li>
<code>options</code> Object
<ul>
<li><code>x</code> Integer</li>
<li><code>y</code> Integer</li>
<li><code>width</code> Integer</li>
<li><code>height</code> Integer</li>
</ul>
</li>
<li><code>animate</code> Boolean (可选) <em>OS X</em></li>
</ul>
<p>重新设置窗口的宽高值，并且移动到指定的 <code>x</code>, <code>y</code> 位置.</p>
<h3><code>win.getBounds()</code></h3>
<p>返回一个对象，它包含了窗口的宽，高，x坐标，y坐标.</p>
<h3><code>win.setSize(width, height[, animate])</code></h3>
<ul>
<li><code>width</code> Integer</li>
<li><code>height</code> Integer</li>
<li><code>animate</code> Boolean (可选) <em>OS X</em></li>
</ul>
<p>重新设置窗口的宽高值.</p>
<h3><code>win.getSize()</code></h3>
<p>返回一个数组，它包含了窗口的宽，高.</p>
<h3><code>win.setContentSize(width, height[, animate])</code></h3>
<ul>
<li><code>width</code> Integer</li>
<li><code>height</code> Integer</li>
<li><code>animate</code> Boolean (可选) <em>OS X</em></li>
</ul>
<p>重新设置窗口客户端的宽高值（例如网页界面）.</p>
<h3><code>win.getContentSize()</code></h3>
<p>返回一个数组，它包含了窗口客户端的宽，高.</p>
<h3><code>win.setMinimumSize(width, height)</code></h3>
<ul>
<li><code>width</code> Integer</li>
<li><code>height</code> Integer</li>
</ul>
<p>设置窗口最小化的宽高值.</p>
<h3><code>win.getMinimumSize()</code></h3>
<p>返回一个数组，它包含了窗口最小化的宽，高.</p>
<h3><code>win.setMaximumSize(width, height)</code></h3>
<ul>
<li><code>width</code> Integer</li>
<li><code>height</code> Integer</li>
</ul>
<p>设置窗口最大化的宽高值.</p>
<h3><code>win.getMaximumSize()</code></h3>
<p>返回一个数组，它包含了窗口最大化的宽，高.</p>
<h3><code>win.setResizable(resizable)</code></h3>
<ul>
<li><code>resizable</code> Boolean</li>
</ul>
<p>设置窗口是否可以被用户改变size.</p>
<h3><code>win.isResizable()</code></h3>
<p>返回 boolean,窗口是否可以被用户改变size.</p>
<h3><code>win.setMovable(movable)</code> <em>OS X</em> <em>Windows</em></h3>
<ul>
<li><code>movable</code> Boolean</li>
</ul>
<p>设置窗口是否可以被用户拖动. Linux 无效.</p>
<h3><code>win.isMovable()</code> <em>OS X</em> <em>Windows</em></h3>
<p>返回 boolean,窗口是否可以被用户拖动. Linux 总是返回 <code>true</code>.</p>
<h3><code>win.setMinimizable(minimizable)</code> <em>OS X</em> <em>Windows</em></h3>
<ul>
<li><code>minimizable</code> Boolean</li>
</ul>
<p>设置窗口是否可以最小化. Linux 无效.</p>
<h3><code>win.isMinimizable()</code> <em>OS X</em> <em>Windows</em></h3>
<p>返回 boolean,窗口是否可以最小化. Linux 总是返回 <code>true</code>.</p>
<h3><code>win.setMaximizable(maximizable)</code> <em>OS X</em> <em>Windows</em></h3>
<ul>
<li><code>maximizable</code> Boolean</li>
</ul>
<p>设置窗口是否可以最大化. Linux 无效.</p>
<h3><code>win.isMaximizable()</code> <em>OS X</em> <em>Windows</em></h3>
<p>返回 boolean,窗口是否可以最大化. Linux 总是返回 <code>true</code>.</p>
<h3><code>win.setFullScreenable(fullscreenable)</code></h3>
<ul>
<li><code>fullscreenable</code> Boolean</li>
</ul>
<p>设置点击最大化按钮是否可以全屏或最大化窗口.</p>
<h3><code>win.isFullScreenable()</code></h3>
<p>返回 boolean,点击最大化按钮是否可以全屏或最大化窗口.</p>
<h3><code>win.setClosable(closable)</code> <em>OS X</em> <em>Windows</em></h3>
<ul>
<li><code>closable</code> Boolean</li>
</ul>
<p>设置窗口是否可以人为关闭. Linux 无效.</p>
<h3><code>win.isClosable()</code> <em>OS X</em> <em>Windows</em></h3>
<p>返回 boolean,窗口是否可以人为关闭. Linux 总是返回 <code>true</code>.</p>
<h3><code>win.setAlwaysOnTop(flag)</code></h3>
<ul>
<li><code>flag</code> Boolean</li>
</ul>
<p>是否设置这个窗口始终在其他窗口之上.设置之后，这个窗口仍然是一个普通的窗口，不是一个不可以获得焦点的工具箱窗口.</p>
<h3><code>win.isAlwaysOnTop()</code></h3>
<p>返回 boolean,当前窗口是否始终在其它窗口之前.</p>
<h3><code>win.center()</code></h3>
<p>窗口居中.</p>
<h3><code>win.setPosition(x, y[, animate])</code></h3>
<ul>
<li><code>x</code> Integer</li>
<li><code>y</code> Integer</li>
<li><code>animate</code> Boolean (可选) <em>OS X</em></li>
</ul>
<p>移动窗口到对应的 <code>x</code> and <code>y</code> 坐标.</p>
<h3><code>win.getPosition()</code></h3>
<p>返回一个包含当前窗口位置的数组.</p>
<h3><code>win.setTitle(title)</code></h3>
<ul>
<li><code>title</code> String</li>
</ul>
<p>改变原窗口的title.</p>
<h3><code>win.getTitle()</code></h3>
<p>返回原窗口的title.</p>
<p><strong>注意:</strong> 界面title可能和窗口title不相同.</p>
<h3><code>win.flashFrame(flag)</code></h3>
<ul>
<li><code>flag</code> Boolean</li>
</ul>
<p>开始或停止显示窗口来获得用户的关注.</p>
<h3><code>win.setSkipTaskbar(skip)</code></h3>
<ul>
<li><code>skip</code> Boolean</li>
</ul>
<p>让窗口不在任务栏中显示.</p>
<h3><code>win.setKiosk(flag)</code></h3>
<ul>
<li><code>flag</code> Boolean</li>
</ul>
<p>进入或离开 kiosk 模式.</p>
<h3><code>win.isKiosk()</code></h3>
<p>返回 boolean,是否进入或离开 kiosk 模式.</p>
<h3><code>win.getNativeWindowHandle()</code></h3>
<p>以 <code>Buffer</code> 形式返回这个具体平台的窗口的句柄.</p>
<p>windows上句柄类型为 <code>HWND</code> ，OS X <code>NSView*</code> ， Linux <code>Window</code>.</p>
<h3><code>win.hookWindowMessage(message, callback)</code> <em>Windows</em></h3>
<ul>
<li><code>message</code> Integer</li>
<li><code>callback</code> Function</li>
</ul>
<p>拦截windows 消息，在 WndProc 接收到消息时触发 <code>callback</code>函数.</p>
<h3><code>win.isWindowMessageHooked(message)</code> <em>Windows</em></h3>
<ul>
<li><code>message</code> Integer</li>
</ul>
<p>返回 <code>true</code> or <code>false</code> 来代表是否拦截到消息.</p>
<h3><code>win.unhookWindowMessage(message)</code> <em>Windows</em></h3>
<ul>
<li><code>message</code> Integer</li>
</ul>
<p>不拦截窗口消息.</p>
<h3><code>win.unhookAllWindowMessages()</code> <em>Windows</em></h3>
<p>窗口消息全部不拦截.</p>
<h3><code>win.setRepresentedFilename(filename)</code> <em>OS X</em></h3>
<ul>
<li><code>filename</code> String</li>
</ul>
<p>设置窗口当前文件路径，并且将这个文件的图标放在窗口标题栏上.</p>
<h3><code>win.getRepresentedFilename()</code> <em>OS X</em></h3>
<p>获取窗口当前文件路径.</p>
<h3><code>win.setDocumentEdited(edited)</code> <em>OS X</em></h3>
<ul>
<li><code>edited</code> Boolean</li>
</ul>
<p>明确指出窗口文档是否可以编辑，如果可以编辑则将标题栏的图标变成灰色.</p>
<h3><code>win.isDocumentEdited()</code> <em>OS X</em></h3>
<p>返回 boolean,当前窗口文档是否可编辑.</p>
<h3><code>win.focusOnWebView()</code></h3>
<h3><code>win.blurWebView()</code></h3>
<h3><code>win.capturePage([rect, ]callback)</code></h3>
<ul>
<li>
<code>rect</code> Object (可选) - 捕获Page位置
<ul>
<li><code>x</code> Integer</li>
<li><code>y</code> Integer</li>
<li><code>width</code> Integer</li>
<li><code>height</code> Integer</li>
</ul>
</li>
<li><code>callback</code> Function</li>
</ul>
<p>捕获 <code>rect</code> 中的page 的快照.完成后将调用回调函数 <code>callback</code> 并返回 <code>image</code> . <code>image</code> 是存储了快照信息的<a href="native-image.html">NativeImage</a>实例.如果不设置 <code>rect</code> 则将捕获所有可见page.</p>
<h3><code>win.print([options])</code></h3>
<p>类似 <code>webContents.print([options])</code></p>
<h3><code>win.printToPDF(options, callback)</code></h3>
<p>类似 <code>webContents.printToPDF(options, callback)</code></p>
<h3><code>win.loadURL(url[, options])</code></h3>
<p>类似 <code>webContents.loadURL(url[, options])</code>.</p>
<h3><code>win.reload()</code></h3>
<p>类似 <code>webContents.reload</code>.</p>
<h3><code>win.setMenu(menu)</code> <em>Linux</em> <em>Windows</em></h3>
<ul>
<li><code>menu</code> Menu</li>
</ul>
<p>设置菜单栏的 <code>menu</code> ，设置它为 <code>null</code> 则表示不设置菜单栏.</p>
<h3><code>win.setProgressBar(progress)</code></h3>
<ul>
<li><code>progress</code> Double</li>
</ul>
<p>在进度条中设置进度值，有效范围 [0, 1.0].</p>
<p>当进度小于0时则不显示进度;
当进度大于0时显示结果不确定.</p>
<p>在libux上，只支持Unity桌面环境，需要指明 <code>*.desktop</code> 文件并且在 <code>package.json</code> 中添加文件名字.默认它为 <code>app.getName().desktop</code>.</p>
<h3><code>win.setOverlayIcon(overlay, description)</code> <em>Windows 7+</em></h3>
<ul>
<li><code>overlay</code> <a href="native-image.html">NativeImage</a> - 在底部任务栏右边显示图标. </li>
<li><code>description</code> String - 描述.</li>
</ul>
<p>向当前任务栏添加一个 16 x 16 像素的图标，通常用来覆盖一些应用的状态，或者直接来提示用户.</p>
<h3><code>win.setHasShadow(hasShadow)</code> <em>OS X</em></h3>
<ul>
<li><code>hasShadow</code> (Boolean)</li>
</ul>
<p>设置窗口是否应该有阴影.在Windows和Linux系统无效.</p>
<h3><code>win.hasShadow()</code> <em>OS X</em></h3>
<p>返回 boolean,设置窗口是否有阴影.在Windows和Linux系统始终返回
<code>true</code>.</p>
<h3><code>win.setThumbarButtons(buttons)</code> <em>Windows 7+</em></h3>
<ul>
<li><code>buttons</code> Array</li>
</ul>
<p>在窗口的任务栏button布局出为缩略图添加一个有特殊button的缩略图工具栏. 返回一个 <code>Boolean</code> 对象来指示是否成功添加这个缩略图工具栏.</p>
<p>因为空间有限，缩略图工具栏上的 button 数量不应该超过7个.一旦设置了，由于平台限制，就不能移动它了.但是你可使用一个空数组来调用api来清除 buttons .</p>
<p>所有 <code>buttons</code> 是一个 <code>Button</code> 对象数组:</p>
<ul>
<li>
<code>Button</code> Object
<ul>
<li><code>icon</code> <a href="native-image.html">NativeImage</a> - 在工具栏上显示的图标.</li>
<li><code>click</code> Function</li>
<li><code>tooltip</code> String (可选) - tooltip 文字.</li>
<li><code>flags</code> Array (可选) - 控制button的状态和行为. 默认它是 <code>['enabled']</code>.</li>
</ul>
</li>
</ul>
<p><code>flags</code> 是一个数组，它包含下面这些 <code>String</code>s:</p>
<ul>
<li><code>enabled</code> - button 为激活状态并且开放给用户.</li>
<li><code>disabled</code> -button 不可用. 目前它有一个可见的状态来表示它不会响应你的行为.</li>
<li><code>dismissonclick</code> - 点击button，这个缩略窗口直接关闭.</li>
<li><code>nobackground</code> - 不绘制边框，仅仅使用图像.</li>
<li><code>hidden</code> - button 对用户不可见.</li>
<li><code>noninteractive</code> - button 可用但是不可响应; 也不显示按下的状态. 它的值意味着这是一个在通知单使用 button 的实例.</li>
</ul>
<h3><code>win.showDefinitionForSelection()</code> <em>OS X</em></h3>
<p>在界面查找选中文字时显示弹出字典.</p>
<h3><code>win.setAutoHideMenuBar(hide)</code></h3>
<ul>
<li><code>hide</code> Boolean</li>
</ul>
<p>设置窗口的菜单栏是否可以自动隐藏. 一旦设置了，只有当用户按下 <code>Alt</code> 键时则显示.</p>
<p>如果菜单栏已经可见，调用 <code>setAutoHideMenuBar(true)</code> 则不会立刻隐藏.</p>
<h3><code>win.isMenuBarAutoHide()</code></h3>
<p>返回 boolean,窗口的菜单栏是否可以自动隐藏.</p>
<h3><code>win.setMenuBarVisibility(visible)</code></h3>
<ul>
<li><code>visible</code> Boolean</li>
</ul>
<p>设置菜单栏是否可见.如果菜单栏自动隐藏，用户仍然可以按下 <code>Alt</code> 键来显示.</p>
<h3><code>win.isMenuBarVisible()</code></h3>
<p>返回 boolean,菜单栏是否可见.</p>
<h3><code>win.setVisibleOnAllWorkspaces(visible)</code></h3>
<ul>
<li><code>visible</code> Boolean</li>
</ul>
<p>设置窗口是否在所有地方都可见.</p>
<p><strong>注意:</strong> 这个api 在windows无效.</p>
<h3><code>win.isVisibleOnAllWorkspaces()</code></h3>
<p>返回 boolean,窗口是否在所有地方都可见.</p>
<p><strong>注意:</strong> 在 windows上始终返回 false.</p>
<h3><code>win.setIgnoreMouseEvents(ignore)</code> <em>OS X</em></h3>
<ul>
<li><code>ignore</code> Boolean</li>
</ul>
<p>忽略窗口的所有鼠标事件.</p>
